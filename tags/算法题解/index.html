<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="BLumia's Dairy Wrapzone" type="application/atom+xml"><link rel="icon" href="/favicon.png"><script src="/easteregg/hi.js"></script><title>算法题解 - BLumia's Dairy Wrapzone</title><link rel="stylesheet" href="/css/main.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><div class="page-background"><div id="triangles-4" class="triangles"></div><div id="triangles-5" class="triangles"></div><div id="triangles-6" class="triangles"></div><div id="gradient-overlay-2"></div></div><header class="head"><nav id="nav-menu" class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Home</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archives</a></li><li class="head-nav__item"><a href="/Creative" class="head-nav__link">Creative</a></li><li class="head-nav__item"><a href="/About" class="head-nav__link">About</a></li></ul></nav><h1 class="head-title"><a href="/">BLumia's Dairy Wrapzone</a></h1><h2 class="sub-title">Is that BLumia's Darkness World before?</h2></header><main class="main"><article class="post"><header class="post__head"><time datetime="2015-08-10T07:12:00.000Z" class="post__time">August 10, 2015</time><h1 class="post__title"><a href="/2015/08/10/HDU-1045(Fire-Net)题解/">HDU 1045(Fire Net)题解</a></h1></header><div class="post__main echo"><p>嘛..markdown爽..那就再爽一次..<br>相应博客园url：<a href="http://www.cnblogs.com/blumia/p/hdu1045.html" target="_blank" rel="external">这里</a><br>题解写的越发的少了，主要也只是因为题写的慢了..莫名其妙的动力减少以及难度增加导致的做题缓慢什么的.. <del>趁着这回写一次凑个数吧</del><br>以防万一，题目原文和链接均附在文末。那么先是题目分析：</p>
<a id="more"></a>
<h2 id="【一句话题意】">【一句话题意】</h2><p>给定大小的棋盘中部分格子存在可以阻止互相攻击的墙，问棋盘中可以放置最多多少个可以横纵攻击炮塔。</p>
<h2 id="【题目分析】">【题目分析】</h2><p>这题本来在搜索专题里出现的..这回又在二分查找匹配专题出现了..所以当然要按照二分匹配的方法解而不是爆搜（虽然爆搜能过）。<br>问题主要就是如何缩点建图。为了使得blockhouse不能互相攻击，那么使用每行的相邻的点缩点，每列的相邻的点缩点，连边的条件就是两个点存在有相交的部分，最后这两组点求最大匹配就行了。</p>
<h2 id="【算法流程】">【算法流程】</h2><p>应该这题也能算是标准题了吧。缩点，建图，hungary匈牙利算法求解，输出答案。完事儿了。<br>匈牙利算法以及二分最大匹配的相关内容这里就不说了。。</p>
<p>下面的代码简单说明，本来的aleft和aright名字叫left和right，后来发现和STL的东西冲突了。。<br>fill的宏定义有更科学的方法，这里就只是单纯的抹0。以及for each是从1到n而不是从0到n。<br>因为习惯问题，数组是从1算起的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#define each(i,n) (int i=1;i&lt;=(n);++i)</span><br><span class="line">#define fill(arr) memset(arr,0,sizeof(arr))</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line"></span><br><span class="line">char map[6][6];</span><br><span class="line">char aleft[6][6];</span><br><span class="line">char aright[6][6];</span><br><span class="line">int l[61], r[61], lCnt, rCnt;</span><br><span class="line">bool graph[61][61];</span><br><span class="line">bool vis[61];</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dfs(int left) &#123;</span><br><span class="line">	for each(right,rCnt) &#123;</span><br><span class="line">		//left到right有路且没遍历过 </span><br><span class="line">		if(graph[left][right] &amp;&amp; !vis[right]) &#123;</span><br><span class="line">			vis[right] = true;</span><br><span class="line">			//若right还没匹配过或跟right匹配的点找到另一个相匹配的点</span><br><span class="line">			//(则right就可以跟left匹配) </span><br><span class="line">			if(r[right]==-1 || dfs(r[right])) &#123;</span><br><span class="line">				r[right] = left;</span><br><span class="line">				l[left] = right;</span><br><span class="line">				//printf("(%d,%d)\n",left,right); </span><br><span class="line">				return 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int hungary() &#123;</span><br><span class="line">	int ans = 0;</span><br><span class="line">	memset(l,-1,sizeof(l));</span><br><span class="line">	memset(r,-1,sizeof(r));	</span><br><span class="line">	for each(i,lCnt) &#123; //row point cnt</span><br><span class="line">		if(l[i] == -1) &#123;</span><br><span class="line">			fill(vis);</span><br><span class="line">			ans += dfs(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	int n;</span><br><span class="line">	char buffer[10];</span><br><span class="line">	while(gets(buffer)) &#123;</span><br><span class="line">		//proc input</span><br><span class="line">		if (buffer[0] == '0') break;</span><br><span class="line">		sscanf(buffer,"%d",&amp;n);</span><br><span class="line">		for each(line,n) &#123;</span><br><span class="line">			gets(buffer);</span><br><span class="line">			for each(col,n) &#123;</span><br><span class="line">				map[line][col] = buffer[col-1];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//create grapth [ Marking up Points ] </span><br><span class="line">		fill(aleft);</span><br><span class="line">		fill(aright);</span><br><span class="line">		lCnt = 1;</span><br><span class="line">		int pre = 0;</span><br><span class="line">		for each(row,n) &#123;</span><br><span class="line">			for each(col,n) &#123;</span><br><span class="line">				if(map[row][col]=='X') &#123;</span><br><span class="line">					if(pre==lCnt) ++lCnt;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				aleft[row][col] = lCnt;</span><br><span class="line">				pre = lCnt;</span><br><span class="line">			&#125;</span><br><span class="line">			if(pre==lCnt) ++lCnt;</span><br><span class="line">		&#125;</span><br><span class="line">		lCnt = pre;</span><br><span class="line">		rCnt = 1;</span><br><span class="line">		pre = 0;</span><br><span class="line">		for each(col,n) &#123;</span><br><span class="line">			for each(row,n) &#123;</span><br><span class="line">				if(map[row][col]=='X') &#123;</span><br><span class="line">					if(pre==rCnt) ++rCnt;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				aright[row][col] = rCnt;</span><br><span class="line">				pre = rCnt;</span><br><span class="line">			&#125;</span><br><span class="line">			if(pre==rCnt) ++rCnt;</span><br><span class="line">		&#125;</span><br><span class="line">		rCnt = pre;</span><br><span class="line">		//create grapth [ Shrinking Points ]</span><br><span class="line">		fill(graph);</span><br><span class="line">		for each(row,n) &#123;</span><br><span class="line">			for each(col,n) &#123;</span><br><span class="line">				if(map[row][col]=='.')</span><br><span class="line">					graph[aleft[row][col]][aright[row][col]] = true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//doWork</span><br><span class="line">		printf("%d\n",hungary());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1045" target="_blank" rel="external">Fire Net（HDU 1045）</a></p>
<p>题目属性：二分图最大匹配 （如果愿意你可以去爆搜..）</p>
<p>相关题目：2444 1083 1281 2819 2389 4185 poj3020 …</p>
<p>题目原文：<br>【desc】<br>Suppose that we have a square city with straight streets. A map of a city is a square board with n rows and n columns, each representing a street or a piece of wall. </p>
<p>A blockhouse is a small castle that has four openings through which to shoot. The four openings are facing North, East, South, and West, respectively. There will be one machine gun shooting through each opening. </p>
<p>Here we assume that a bullet is so powerful that it can run across any distance and destroy a blockhouse on its way. On the other hand, a wall is so strongly built that can stop the bullets. </p>
<p>The goal is to place as many blockhouses in a city as possible so that no two can destroy each other. A configuration of blockhouses is legal provided that no two blockhouses are on the same horizontal row or vertical column in a map unless there is at least one wall separating them. In this problem we will consider small square cities (at most 4x4) that contain walls through which bullets cannot run through. </p>
<p>The following image shows five pictures of the same board. The first picture is the empty board, the second and third pictures show legal configurations, and the fourth and fifth pictures show illegal configurations. For this board, the maximum number of blockhouses in a legal configuration is 5; the second picture shows one way to do it, but there are several other ways. </p>
<p><img src="http://blogblumia-typecho.stor.sinaapp.com/usr/uploads/2015/08/2630942644.jpg" alt="看我多良心，还给备个图"></p>
<p>Your task is to write a program that, given a description of a map, calculates the maximum number of blockhouses that can be placed in the city in a legal configuration.<br>【In】<br>The input file contains one or more map descriptions, followed by a line containing the number 0 that signals the end of the file. Each map description begins with a line containing a positive integer n that is the size of the city; n will be at most 4. The next n lines each describe one row of the map, with a ‘.’ indicating an open space and an uppercase ‘X’ indicating a wall. There are no spaces in the input file.<br>【Out】<br>For each test case, output one line containing the maximum number of blockhouses that can be placed in the city in a legal configuration.<br>【SampIn】</p>
<pre>4
.X..
....
XX..
....
2
XX
.X
3
.X.
X.X
.X.
3
...
.XX
.XX
4
....
....
....
....
0</pre>
【SampOut】
<pre>5
1
5
2
4</pre>


</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/算法题解/" class="post__tag__link">算法题解</a></li></ul><a href="/2015/08/10/HDU-1045(Fire-Net)题解/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2015-07-20T05:55:00.000Z" class="post__time">July 20, 2015</time><h1 class="post__title"><a href="/2015/07/20/POJ-3279(Fliptile)题解/">POJ 3279(Fliptile)题解</a></h1></header><div class="post__main echo"><p>能用Markdown排版真爽。于是头一回打算先把题解发在这个我本来只发所谓日记的地方…<br>相应博客园url：<a href="http://www.cnblogs.com/blumia/p/poj3279.html" target="_blank" rel="external">这里</a><br>以防万一，题目原文和链接均附在文末。那么先是题目分析：</p>
<a id="more"></a>
<h2 id="【一句话题意】">【一句话题意】</h2><p>给定长宽的黑白棋棋盘摆满棋子，每次操作可以反转一个位置和其上下左右共五个位置的棋子的颜色，求要使用最少翻转次数将所有棋子反转为黑色所需翻转的是哪些棋子（这句话好长…）。</p>
<h2 id="【题目分析】">【题目分析】</h2><p>盯着奇怪的题目看了半天发现和奶牛没什么卵关系..奶牛智商高了产奶高是什么鬼说法…</p>
<p>这题刚开始被放到搜索的分类下了..然而这和搜索有什么关系..没经验所以想了各种和搜索沾边的方法，结果没想出解法，直到看了网上的题解，压根不是搜索啊有木有。</p>
<p>然后这题网上给的分类是简单题..简单题..蒟蒻跪了..</p>
<p>好了开始说解法。首先根据题目，每次操作都会影响到周围的“棋子”，而要使得每个1都被反转为0，那么我们就应当每次都反转1下方的棋子以改变1为0.</p>
<p>那么，当我们处理过1到n-1行的时候，前n-1行就都已经是0了，最后我们只需要检查最后一行是不是全部为0就可以检查这次的出操作是否正确了。如果正确且最小，那就存起来。最后输出，万事大吉。</p>
<p>当然，因为我们要改变第x行的1为0需要反转的是x+1行的位置。而这个整个规则是我们验证一组操作是否能达到目的所用的，那么我们需要在验证前先确定操作（没操作怎么验证..）。</p>
<p>于是根据规则内容可知，只需要能确认第一行的翻转情况，就能够推出下面所有的翻转情况并验证是否正确。于是需要做的就是枚举第一行的情况了。</p>
<h2 id="【算法流程】">【算法流程】</h2><p>整个代码分了四部分，处理输入部分没啥可说的，接下来就是doWork干活部分了..</p>
<p>需要干的活就是枚举第一行的所有情况然后对于每次枚举都计算验证是否符合要求以及反转所需的次数。其中，第一行的状态数量可以使用左移运算优化（效率比pow高），于是总共枚举的数量就有1&lt;&lt;col次。另外，因为这使得一行的状态是由一个数字保存的，所以依然使用位运算取得是否翻转的状态。</p>
<p>将枚举好的一次首行状态存好后就可以交给calc计算和验证了。验证就是通过上述翻转规则操作。其中get(x,y)为取得某个位置是否为1的状态的方法（过程）。</p>
<p>最后检查结果就好。下面是代码。<br>哦对了，我似乎滥用了each宏定义…无视即可。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define each(i,n) (int i=1;i&lt;=(n);++i)</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int row,col;</span><br><span class="line">int arr[20][20];</span><br><span class="line">int flip[20][20],ans[20][20];</span><br><span class="line">int dir[5][2] = &#123;</span><br><span class="line">	0,0, 0,1, 0,-1, -1,0, 1,0 </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int get(int x,int y) &#123;</span><br><span class="line">	int c = arr[x+1][y+1];</span><br><span class="line">	for(int i = 0;i&lt;5;i++) &#123;</span><br><span class="line">		int dx = x + dir[i][0];</span><br><span class="line">		int dy = y + dir[i][1];</span><br><span class="line">		if(dx &gt;=0 &amp;&amp; dx&lt;row &amp;&amp; dy&gt;=0 &amp;&amp; dy&lt;col) &#123;</span><br><span class="line">			c+=flip[dx][dy];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return c&amp;1; // with flip state, if odd return 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int calc() &#123;</span><br><span class="line">	for each(i,row-1) &#123;</span><br><span class="line">		for(int j = 0;j&lt;col;j++) &#123;</span><br><span class="line">			if(get(i-1,j)) ++flip[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;col;i++) &#123; // check last line</span><br><span class="line">		if(get(row-1,i)) return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int cnt = 0;</span><br><span class="line">    for (int i=0;i&lt;row;i++) &#123; //统计翻转的次数  </span><br><span class="line">        for (int j=0;j&lt;col;j++) &#123;</span><br><span class="line">    		cnt += flip[i][j];  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void doWork() &#123;</span><br><span class="line">	int cnt = INF;</span><br><span class="line">	for(int i=0;i&lt;(1&lt;&lt;col);i++) &#123; //from 0000 to 1111</span><br><span class="line">		memset(flip,0,sizeof(flip));</span><br><span class="line">		for(int j=0;j&lt;col;j++) &#123;</span><br><span class="line">			flip[0][col-j-1] = (i&gt;&gt;j)&amp;1; //get pos state form binary number</span><br><span class="line">		&#125;</span><br><span class="line">		int num = calc();</span><br><span class="line">		if (num&lt;cnt &amp;&amp; num!=0) &#123;</span><br><span class="line">			cnt = num;</span><br><span class="line">			memcpy(ans,flip,sizeof(flip));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (cnt==INF) printf("IMPOSSIBLE\n");</span><br><span class="line">	else &#123;</span><br><span class="line">		for (int i=0;i&lt;row;i++) &#123;  </span><br><span class="line">            printf("%d",ans[i][0]);  </span><br><span class="line">            for each(j,col-1) &#123;</span><br><span class="line">                printf(" %d",ans[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            printf("\n");  </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	</span><br><span class="line">	while(~scanf("%d%d",&amp;row,&amp;col)) &#123;</span><br><span class="line">		memset(arr,0,sizeof(arr));</span><br><span class="line">		for each(i,row) &#123;</span><br><span class="line">			for each(j,col) &#123;</span><br><span class="line">				scanf("%d",&amp;arr[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		doWork();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>题目链接：<a href="http://poj.org/problem?id=3279" target="_blank" rel="external">Fliptile（POJ 3279）</a></p>
<p>题目属性：枚举 简单优化 （我真不知道算不算搜索…）</p>
<p>相关题目：poj3276</p>
<p>题目原文：<br>【desc】<br>Farmer John knows that an intellectually satisfied cow is a happy cow who will give more milk. He has arranged a brainy activity for cows in which they manipulate an M × N grid (1 ≤ M ≤ 15; 1 ≤ N ≤ 15) of square tiles, each of which is colored black on one side and white on the other side.</p>
<p>As one would guess, when a single white tile is flipped, it changes to black; when a single black tile is flipped, it changes to white. The cows are rewarded when they flip the tiles so that each tile has the white side face up. However, the cows have rather large hooves and when they try to flip a certain tile, they also flip all the adjacent tiles (tiles that share a full edge with the flipped tile). Since the flips are tiring, the cows want to minimize the number of flips they have to make.</p>
<p>Help the cows determine the minimum number of flips required, and the locations to flip to achieve that minimum. If there are multiple ways to achieve the task with the minimum amount of flips, return the one with the least lexicographical ordering in the output when considered as a string. If the task is impossible, print one line with the word “IMPOSSIBLE”.<br>【In】<br>Line 1: Two space-separated integers: M and N<br>Lines 2.. M+1: Line i+1 describes the colors (left to right) of row i of the grid with N space-separated integers which are 1 for black and 0 for white<br>【Out】<br>Lines 1.. M: Each line contains N space-separated integers, each specifying how many times to flip that particular location.<br>【SampIn】<br>4 4<br>1 0 0 1<br>0 1 1 0<br>0 1 1 0<br>1 0 0 1<br>【SampOut】<br>0 0 0 0<br>1 0 0 1<br>1 0 0 1<br>0 0 0 0</p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/算法题解/" class="post__tag__link">算法题解</a></li></ul><a href="/2015/07/20/POJ-3279(Fliptile)题解/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2016 <a onclick='high();'>BLumia</a></div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><span title="Next" class="page-menu__link icon-arrow-right page-menu__link--disabled"></span></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})
(document,"script","blogblumia","count");
</script></body></html>